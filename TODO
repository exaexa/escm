
	 _______         _____        
	|_     _|.-----.|     \.-----.
	  |   |  |  _  ||  --  |  _  |
	  |___|  |_____||_____/|_____|


	general escm todo


] we might catch memory exceptions as real c++ exceptions. Otherwise check
	if all new_scm's are checked for returning zero.

] come up with some reasonable hash function for hashed_frame.

] make collector heap dynamic 
	(at least growable to some defined extent, possibly non-continuous)

] What the hell should happen, when we run out of memory?!
	should THAT be allowed? should we free some memory and run an exception?
	Guess that allocating nil is really not the best idea we have.

] oooh that^ reminds me - someone should think about exceptions. :D
	we should have *error-hook*, which is lambda and (error) which
	calls it a little. Default *error-hook* lambda is internal and causes
	some kind of continuation crash;)

] As we replace continuations, we come to problem that they might be still
	running when are already garbage collected. No need to say what would
	happen when we wrote in the corresponding class instance after that.
	We could add some optical solution which solves it (e.g. returning
	some kind of functor which pushes the thing when it's safe)

] Support for call/cc needs the continuation objects to be "somehow callable".
	for example this way - save a parameter to val (so it seems to be
	returned by the computation) and just switch the scm_env->cont?
	(maybe some stack pops would possibly need to occur)
